# 字符集与字符编码

## 为什么要有字符编码

我们知道，计算机底层只认识0、1，即电路的断开、闭合，那么为了让计算机能够存储并处理人类世界中的文字、数字、标点符号等字符，我们需要将这些字符映射成计算机认识的01序列，也就是字节流，当然不能随意映射，需要有一个统一的字符和二进制的映射标准，这就是字符编码标准。

例如，ASCII编码，其中`u`字符被编码为十进制117，对应二进制`0111 0101`，这个过程就是**编码**，即将字符转换成字节流的过程。当计算机采用ASCII编码的时候，读到了字节流`0111 0101`，会根据ASCII编码将这个字节转换成`u`字符，这个过程就是**解码**，即将字节流转换成字符。

## 在分层模型中的体现

在OSI七层模型中，编码和解码发生**表示层**（TCP/IP模型中属于应用层）（图片来自：[OSI Model](https://www.imperva.com/learn/application-security/osi-model)）：

![osi_tcp_model_layer](character_set_assets/osi_tcp_model_layer.png)

当我们接收一份数据的时候，从物理层一层一层的解析，这个过程中数据都是以二进制传输的，直到表示层，根据ASCII、JPEG、MPEG、XML等协议或格式，将二进制转换成字符、图片、视频、对象供应用层的应用和协议使用（HTTP、SMTP）。

发送数据则反过来，在表示层将字符等转换成二进制格式，再经过会话层、传输层等进行包装，直到物理层。

在Java中，我们将对象序列化成JSON格式的时候，就是将对象根据JSON和指定的字符编码转换成字节流的过程，以便进行传输和存储。

## 字符编码的诞生需要哪些步骤

首先，需要**确定字符集的范围**，如ASCII编码一共收录了128个字符，GB2312字符集收录7445个字符，确定了字符集的范围，我们才能确定采用几个字节表示一个字符，例如ASCII编码采用一个字节就足以表示128个字符。

其次，需要对字符进行逻辑**编号**：

- 可以按顺序进行编号，例如：ASCII中，A为65，B为66

- 还可以按照区位码的方式进行编号，例如，GB2312中，汉字`王`，这个字被放在了第45区的第85位，所以`王`对应的区位码是4585

最后，需要将逻辑编号进行**编码**，让计算机能够正确的读取，这个步骤我们需要思考两个问题：

- **计算机一次应该读取几个字节？**

  有的字符编码一次读一个字节，有的字符编码一次读两个字节，还有的字符编码一次读四个字节，我们把计算机一次读取的字节数称为**码元（Code Unit）**。

- **几个码元表示一个字符？**

  例如ASCII，码元为一个字节，那么一个字符占一个码元，即可表示128个字符，所以对于ASCII码，计算机一次读取一个字节，一个字节对应了一个字符。

  但是，有的字符集，一个字符可能需要多个码元来表示，这就需要进行特定规则的编码，告诉计算机，几个码元表示的是一个字符。

  例如UTF-8，码元也是一个字节，但是一到四个码元表示一个字符，这时候就需要一些编码规则，并按照这些规则将编号进行编码，那么计算机根据这个编码规则，就知道几个码元表示一个字符了（具体的规则后面的UTF-8会详解）。

  故对于UTF-8，计算机一次读取一个字节，然后根据UTF-8的编码规则，将一到四个字节转换成一个字符。

## ASCII

ASCII（American Standard Code for Information Interchange）编码，美国信息互换标准编码，单字节编码方案，最高位用于奇偶校验，所以一共128个字符，这个比较简单，直接将0-127这128个编号直接映射为单字节的二进制数据。

如下图所示：

![ascii_code_chart](character_set_assets/ascii_code_chart.png)

## GB系列

### GB2312

GB2312（GB：国标）是1980年我国发布的简体中文字符集，共收录6763个汉字以及682个全角字符。

GB2312提出了分区的概念，一共94个区，每个区可以放94个字符（类似行和列），所以定位一个字符的方式就是在第几分区的第几位字符。

分区可以让字符分门别类的存放：

- 01~09区：特殊符号、数字、英文字符、制表符等
- 10~15区：待扩展
- 16~55区：常用汉字（以拼音字母排序）
- 56~87区：非常用汉字（以部首笔画排序）
- 88~94区：待扩展

例如，汉字`王`，这个字被放在了第45区的第85位，所以`王`对应的`区位码`是`4585`。

编码规则：

- 把区位码的区码和位码都加`160`，`45+160=205`，`85+160=245`
- 分别拼成两个字节，`11001101 11110101`，对应16进制CDF5

总结：

- 一个小于127的字符的意义与原来相同
- 两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（高字节）从`0xA1`用到`0xF7`，后面一个字节（低字节）从`0xA1`到`0xFE`

注意：

- 关于全角字符

  GB2312并未收录ASCII编码中的字符，而是将其重新编成了两个字节，这就是常说的全角字符，ASCII编码中的字符就叫做半角字符了。

- 为什么将区位码加160？

  为了避开ASCII字符中的不可显示字符（直接沿用，不再重新编码），即0-31个，及第32个，空格字符，所以在区位码的基础上，高位和低位分别加上32，做为国标码，但是这种编码模式和ASCII是有冲突的，后来为了方便区分单字节编码还是双字节编码，部分厂商把双字节字符的二进制最高位从0换成了1，相当于将区位码高位和低位再加上了128，32+128=160，所以相当于区位码直接加了160。

### GBK

GB2312虽然满足了日常基本使用，但是还有有一些生僻字未收录，例如总理朱镕基的"镕"字、香港和台湾使用的繁体字都没有收录，所以出现了GB2312的扩展版本，GBK（K，扩展），兼容GB2312，包括了Unicode 1.1中的汉字，共收录了21003个汉字。

GB2312采用了`94*94`的范围，GBK将两字节能表示的区域进一步扩大，共计23940个码位：

- 首先不避开ASCII中不可显示的字符，能表示的区域就扩大成了`128*128`，对应16进制为`0x80*0x80`（`0x`代表16进制表示）。

- 进一步的，要想避免和ASCII发生冲突，只需要第一个字节大于128即可，读取的时候，如果一个字节大于128，那么连续读取两个字节即可，所以第二个字节的范围可以进一步扩大，GBK将第二个字节的范围从GB2312的`128–254`扩展到了`64–254`。

布局图如下图所示：

![GBK_encoding](character_set_assets/GBK_encoding.svg)

其中：

- GBK/1和GBK/2区域为原来的GB2312编码，GBK/1代表非汉字区，GBK/2代表汉字区
- GBK/3、GBK/4、GBK/5为GBK新增区域
- 红色区域为用户自定义区域

注意：

GBK是国家有关部门与一些信息行业企业等一起合作推出的方案，并非官方标准，由于Windows 95的广泛使用，导致GBK成为事实标准。

### GB18030

2000年，我国发布GB18030的初代版本GB18030-2000，最新的为2005年的GB18030-2005，包含多种我国少数民族文字，收入汉字70000余个。

GB18030是一个多字节编码方案，有三种变长组合：

- 单字节，对应ASCII
- 双字节，对GBK进行扩展，编码还是GB系列类似的规则
- 四字节，映射了Unicode中的字符

GB18030完全兼容GB2312，基本兼容 GBK，完全支持Unicode，GB18030只有少数操作系统支持，具体编码规则不再讲解。

## Unicode

Unicode的历史如下：

- 1987年，施乐公司的Joe Becker和苹果公司的Lee Collins和Mark Davis开始研究通用字符

- 1988年，Joe Becker发布了Unicode草案，该草案中Unicode采用16位编码模型，**当时认为16位足以包含世界上任意字符**

- 1991年，成立了Unicode联盟，同年，Unicode1.0发布，共7129个字符

- 1992年，Unicode1.0.1发布，包括了20902个CJK字符

  （CJK，中日韩统一表意文字，把分别来自中文、日文、韩文、越文中，起源相同、本义相同、形状一样的表意文字在Unicode中赋予相同的码点值）

- 1996年，Unicode2.0发布，Unicode的16位不够用了，**定义了代理区，同时新增个16个平面**

- ...

- 2022年，Unicode15.0发布，添加了4,489个字符，其中绝大多数还是CJK字符，当前共计149,186个字符

上面提到，Unicode最初是16位的，也就是2个字节，65,536个编号，后续两个字节不够用了，就新增了16个平面，每个平面也都是两个字节，而最初的Unicode，被称为第0平面，也叫做基本平面（Basic Multilingual Plane，BMP），后面新增的16个平面，被称作增补平面（supplementary planes）。

Unicode字符集中的编号通常用下面方式表示：

```
U+hhhhhh
```

前两位表示位于哪个平面，取值为`0x00-0x10`，故Unicode的最后一个码点，即第16个平面的最后一个码点的Unicode编号为`U+10FFFF`；再如，`王`字的十六进制编号是`738B`，所以我们就写成`U+738B`。

Unicode的17个平面如下图所示（目前Unicode15.0，有5个平面被分配了字符）：

![unicode_plane](character_set_assets/unicode_plane.png)

下面是基本平面的分布：

![Roadmap_to_Unicode_BMP](character_set_assets/Roadmap_to_Unicode_BMP.png)

我们可以看到橘红色为CJK字符，占了基本平面中很大的一部分，还有浅灰色为UTF-16的代理区，后面会讲解。

### 编码方案

Unicode的编号只是逻辑编号，在实际计算机传输的时候，依然要考虑我们开篇提到的两个问题：

- 计算机一次应该读取几个字节？
- 几个码元表示一个字符？

接下来我们看下主流的三种Unicode编码，UTF-8、UTF-16、UTF-32各自采取的编码方案。

#### UTF-32

我们先看最简单的编码方案，UTF-32。

这种编码方案的码元采用4个字节。由于Unicode只有17个平面，每个平面是2个字节，4个字节足以直接映射所有Unicode字符，所以UTF-32不需要任何编码，直接将Unicode逻辑编号直接映射为4字节编码即可，不够4个字节的高位补0即可。

例如：

字符`u`，Unicode编号是`U+0075`，在第0平面，二进制`1110101`，所以编码为：

```
00000000 00000000 00000000 01110101
```

再看字符😂，Unicode编号是`U+1F602`（[点此查询Unicode符号](https://unicode-table.com/cn/)），在第一增补平面，二进制`0001 1111 0110 0000 0010`，所以就直接编码为：

```
00000000 00000001 11110110 00000010
```

UTF-32的特点是定长编码，计算机在读取的时候，一次读取4个字符，并作为一个符号，但是无论任何字符，都是四个字节，浪费了大量空间，因此，UTF-32应用很少。

#### UTF-8

接下来我们看Unicode最优秀的编码方案，UTF-8。

设计UTF-8主要的原因是UTF-16并不兼容ASCII码，所以UTF-8采用了单字节码元，兼容ASCII码，是变长编码，那么就要解决上面的第二个问题，几个码元表示一个字符？

UTF-8采用了非常精巧的设计，根据首字节有几个连续的1的方式（0为终止标志）来判断一个字符几个字节，非首字节都要用10开头（为了区别单字解释编码和多字节编码的首字节）：

- 如果首字节以`0`开头，是单字节编码（1个码元），`0XXX XXXX`，共7个有效位
- 如果首字节以`110`开头，是双字节编码（2个码元），`110XXXXX 10XXXXXX`，共11个有效位
- 如果首字节以`1110`开头，是三字节编码（3个码元），`1110XXXX 10XXXXXX 10XXXXXX`，共16个有效位
- 如果首字节以`11110`开头，是四字节编码（4个码元），`11110XXX 10XXXXXX 10XXXXXX 10XXXXXX`，共21个有效位
- ...

例如：

字符`u`，Unicode编号是`U+0075`，二进制`111 0101`，按照上述规则，编码为：

```
01110101
```

再如基本平面的字符`武`，编号为`U+6B66`，二进制`110 1011 0110 0110`，15个有效位，应该采用三字节编码，填充至上述三字节编码格式格式中，并高位补0：

```
11100110 101011 01 1010 0110
```

再看增补平面字符😂，Unicode编号是`U+1F602`，二进制`1 1111 0110 0000 0010`，17个有效位，所以应采用四字节编码，填充至上述四字节编码格式格式中，并高位补0：：

```
11110000 10011111 10011000 10000010
```

UTF-8的优点如下：

- 兼容ASCII编码，对于ASCII编码，只需一个字节即可
- 具备扩展性，不局限于17个平面
- 自动纠错性能好，适合网络传输，因为每个字符都有前缀，能方便的分辨一个字节是否是一个字符的开头

UTF-8的缺点就是所有变长编码的通用问题，即在程序处理的时候，无法做到随机访问。

由于UTF-8优秀的设计，大部分网站采用的都是UTF-8编码，无历史包袱的软件、系统也基本都会采用UTF-8编码，**大有一统之势**。

注意，理论上UTF-8是可以无限扩大的，例如读到`1111 1111 10xx xxxx`，可以认为是9个码元组成的一个字符，但是实际上，4个字节编码，有21个有效位，而Unicode第16增补平面的最后一位编号为`U+10FFFF`，也21个有效位，所以，4个字节的UTF-8足以表示17个平面，这就是大家所说的**UTF-8为变长编码，由1-4个字节构成**，这也足以看出了UTF-8编码强大的扩展性。

#### UTF-16

由于Unicode最早设计就是2字节编码，那么直接将编号映射为2个字节的编码方式就是最简单的编码方式，即UCS-2（ISO组织的编码标准，后来ISO和Unicode联盟进行合作，二者编码基本一致）。

但是后来发现2个字节不够用了，ISO提出了UCS-4的方案，即4个字节表示一个字符，与UTF-32的方式相同，而Unicode则提出了UTF-16，采用代理机制实现拓展。

UTF-16代理机制就是**采用两个位于基本平面代理区（Surrogate Zone）的码元（2个字节），来表示一个增补平面的码点**。

增补平面一共16个，编号为`0x10000 ~ 0x10FFFF`，共需要20位来表示。

Unicode基本平面中的`0xD800 ~ 0xDFFF`区域被划定为代理区（上面BMP图中浅灰色区域，没有对应任何字符），对应的二进制为：`1101 1000 0000 0000 ~ 1101 1111 1111 1111` ，只要在代理区，那么二进制开头一定是`1101 1`，共计5位，一个码元还剩下11个有效位，1个位置可以表示两个代理码元的高低标志位，还剩下10个有效位，两个高低位码元加起来，刚好20位，而一个增补平面字符也刚好需要20位来表示。

20位中，前4位表示了第几平面，所以最终形式如下：

```
1101 10pp ppxx xxxx  1101 11xx xxxx xxxx
```

其中`pppp`表示所在的平面，其他16位表示所在平面的位置的2进制，且上面形式中的第一位（第6位为0）表示为高16位代理码元，后16位（第6位为1）被称为低16位代理码元。

例如：

字符`u`，Unicode编号是`U+0075`，二进制`0111 0000`，在基本平面，那么就直接将其编号映射为编码：

```
00000000 01110101
```

再如基本平面的字符`武`，编号为`U+6B66`，二进制`0110 1011 0110 0110`，同样的，直接映射为编码：

```
0110 1011 0110 0110
```

又如增补平面字符😂，Unicode编号是`U+1F602`，二进制`0001 1111 0110 0000 0010`，按照上面的形式进行填充（同样高位补零），最终编码如下：

```
1101 1000 0111 1101  1101 1110 0000 0010
```

UTF-16的缺点如下：

- 编码复杂
- 不兼容ASCII编码
- 不具备扩展性，只能基于17个平面
- 同为变长编码，判断一个字符几个字节上，成本要比UTF-8高，UTF需要判断开头几个1即可
- 相比UTF-8存在字节顺序标记问题（后续会提到）

优点：

- 大部分中文编码为两个字节
- 兼容最初的UCS-2方案

所以使用UTF-16编码的多数都是较早支持Unicode的软件系统，Windows、Java等，后续为了兼容选择UTF-16，后续新软件没有必要使用UTF-16。

### 字节顺序标记

字节顺序标记（byte order mark，BOM），在文本文件的最开头，有如下作用：

- 指示了文件使用的编码格式
- 指示了字符编码的高有效位是否存储在文件的初始位置，当字符编码的高有效位被存储在文件的初始位置，被称为"大端序"（big-endian），否则，称为"小端序"

Unicode使用了U+FEFF字符做为字节标记顺序：

| 编码                     | BOM         |
| ------------------------ | ----------- |
| UTF-8                    | EF BB BF    |
| UTF-16BE (big-endian)    | FE FF       |
| UTF-16LE (little-endian) | FF FE       |
| UTF-32BE (big-endian)    | 00 00 FE FF |
| UTF-32LE (little-endian) | FF FE 00 00 |

以字符`u`为例：

| 编码     | 二进制                              |
| -------- | ----------------------------------- |
| UTF-16BE | 00000000 01110101                   |
| UTF-16LE | 01110101 00000000                   |
| UTF-32BE | 00000000 00000000 00000000 01110101 |
| UTF-32LE | 01110101 00000000 00000000 00000000 |

微软系统及系统软件钟爱BOM，很多要求必须有BOM，并不是所有程序都支持BOM，类Unix系统不推荐添加BOM，所以在解析的时候，文件的开头需要注意是否有BOM。

注意：UTF-8不存在顺序问题，如果出现BOM仅仅是为了说明该编码格式为UTF-8。

### 在线转换注意

有时候想查一下一个字符对应的UTF-8编码是啥，就会去搜索utf-8在线转换，但是实际上，大部分中文在线UTF-8转换工具都是错的，经测试（2022年11月18日），百度搜索出来第一页的UTF-8在线转换中，只有一个是对的，其他所有都是返回的该字符的UTF-16。

例如，上面测算过的`😂`，对应的Unicode为`U+1F602`，正确的UTF-8编码为`0xF0 9F 98 82`，但很多在线工具返回的是`&#xD83D;&#xDE02`，这是该字符的UTF-16编码。

在查询的字符的UTF-8编码的时候注意，可以使用如下转换工具：[UTF8 Encode Decode](https://convertcodes.com/utf8-encode-decode-convert-string/)、[Unicode字符百科](https://unicode-table.com/cn/)。

### Unicode相关

#### Java中的影响

Java设计之初的基本假设是，基于Unicode，设计Char，上面也提到了，起初Unicode是16位编码，定长的，自然Java的Char也设计为16位，两个字节，表示一个字符。

但是Unicode2.0，设计了增补平面，两个字节已经不够用了，Java为了兼容旧的接口和虚拟机，没有直接切换为UTF-8，而是采用UTF-16编码，一个Char字符表示UTF-16的一个码元，而不是一个真正的字符，增补字符采用两个Char来表示。

详细历史和相关API详见：[Supplementary Characters in the Java Platform](https://www.oracle.com/technical-resources/articles/javase/supplementary.html)。

代码示例如下：

```java
public class CharacterSet {
    public static void main(String[] args) {
        String s = "😂";
        ///编译报错
        //char c = '😂';
        char[] charArray = s.toCharArray();
        //结果为2
        System.out.println(charArray.length);
        //结果为2
        System.out.println(s.length());
        //新API 获取真正字符数 结果为1
        System.out.println(s.codePointCount(0, s.length()));
    }
}
```

#### MySQL字符集

2004年，MySQL 4.1是第一个支持字符集和排序的版本，其中就包括了utff8，但是由于大部分字符都在基本平面，Mysql选择了优化，规定UTF-8为三个字节，当时几乎可以处理所有现代语言。

2010年，MySQL 5.5开始支持4个字节的UTF-8，而且引入了新的字符集，utf8mb4。

所以utf8mb4才是未被阉割的UTF-8，**在我们使用MySQL的时候，最好使用utf8mb4来做为字符集**。

#### 正则表达式判断汉字

当我们需要判断输入字符是否是汉字的时候，大多数文章都会告诉你去会判断其Unicode是否在`\u4e00-\u9fa5`，这个区间其实是Unicode1.0.1发布，添加的20902个CJK字符，其实已经包括了大部分中文简体、繁体，但是后续又陆陆续续在基本平面和增补平面添加了一些CJK字符，**需要根据需求场景来判断是否还要算上其他CJK区间**。

#### 关于Emoji

Emoji源自1997年的日本手机的操作系统中，后来，一些公司也将Emoji引入到操作系统中，谷歌和苹果在Unicode的私有区域实现了Emoji， 2010 年，Unicode联盟发布Unicode 6.0，其中包括了722个Emoji。

Emoji的字符编码是没有版权的，遵守Unicode联盟的条款即可，但是对应不同公司设计的图案是有版权的，好比字符编码和字体的关系一样，当然，也有部分公司的设计图案是开源的，例如Google。

例如，不同公司设计的Face with Tears of Joy表情图案（`U+1F602`）：

![diff_face_with_tears_of_joy](character_set_assets/diff_face_with_tears_of_joy.png)

注意，我们在使用软件的时候，会发现不同软件也有自己的表情符号，例如贴吧的滑稽、微博的狗头等，这些其实是多个字符按照一定规则的一种映射，在应用层面进行转换，只能在应用内部使用。例如，贴吧的滑稽：`#(滑稽)`，微博的狗头：`[doge]`

## 总结

- 为什么要有字符编码，原因就是计算机只能识别1、0字符，我们需要按照一定规则将现实符号映射为字节流，这个映射标准就是字符编码
- 一个字符集的诞生，需要注意两个问题：计算机一次应该读取几个字节？几个码元表示一个字符？
- GB系列编码，都采用了类似的编码方案，区位码作为编号，并简单射影到两个字节上
- Unicode从最开始采用了双字节编码方案，后来增加了16个增补平面
- UTF-8、UTF-16、UTF-32各自的编码方案及优缺点：
  - UTF-8最为优秀，兼容ASCII编码，使用率也是最高的
  - UTF-16主要考虑了历史兼容问题，有历史包袱的软件系统会采用UTF-16
  - UTF-32特点是定长编码、空间占用大
- 最后Unicode在Java、Mysql中存在一些历史问题，了解Unicode，能帮助我们如何判断汉字，以及生活中常见的Emoji也和Unicode息息相关

## References

1. 博客：[字符集与编码（九）——GB2312，GBK，GB18030](https://my.oschina.net/goldenshaw/blog/352859)
1. 维基百科：[GB 2312](https://zh.m.wikipedia.org/zh-hk/GB_2312)
1. 维基百科：[GB 18030](https://en.wikipedia.org/wiki/GB_18030)
1. 博客：[字符集与编码（四）——Unicode](https://xiaogd.net/md/字符集与编码（四）-unicode)
1. 维基百科：[Unicode](https://en.wikipedia.org/wiki/Unicode)
1. 维基百科：[Plane_(Unicode)](https://en.wikipedia.org/wiki/Plane_(Unicode))
1. 维基百科：[CJK Unified Ideographs](https://en.wikipedia.org/wiki/CJK_Unified_Ideographs)
1. 维基百科：[UTF-8](https://en.wikipedia.org/wiki/UTF-8)
1. 维基百科：[UTF-16](https://en.wikipedia.org/wiki/UTF-16)
1. 维基百科：[Byte order mark](https://en.wikipedia.org/wiki/Byte_order_mark)
1. 博客：[刨根究底字符编码之十三——UTF-16编码方式](https://zhuanlan.zhihu.com/p/27417641)
1. 博客：[刨根究底字符编码之十二——UTF-8究竟是怎么编码的](https://zhuanlan.zhihu.com/p/27364614)
1. 博客：[刨根究底字符编码之十一——UTF-8编码方式与字节序标记BOM](https://zhuanlan.zhihu.com/p/27222802)
1. 官方文档：[Supplementary Characters in the Java Platform](https://www.oracle.com/technical-resources/articles/javase/supplementary.html)
1. 官方文档：[MySQL 8.0: When to use utf8mb3 over utf8mb4?](https://dev.mysql.com/blog-archive/mysql-8-0-when-to-use-utf8mb3-over-utf8mb4/)
1. 知乎：[Java 为什么使用 UTF-16 而不是更节省内存的 UTF-8？](https://www.zhihu.com/question/308677093/answer/2748648048)
1. 维基百科：[Emoji](https://en.wikipedia.org/wiki/Emoji)
1. 知乎：[表情符号是否受版权保护](https://zhuanlan.zhihu.com/p/494278681)



