# Java面试题

## 虚拟机

### JVM的内存区域是怎么划分的

首先我们按照是否是线程隔离来划分：

线程隔离的内存区域：

首先是程序计数器，它记录的是当前线程正在执行的字节码指令的地址。

其次是Java虚拟机栈，也就是我们常说的栈空间，它是描述的是Java方法执行的模型，每个方法执行的时候，虚拟机会创建一个栈帧用于存储局部变量等信息。每个方法被调用，就意味着一个栈帧的入栈到出栈的过程。

还有本地方法栈，存储Java执行Native方法所需要的数据。

接下来是内存共享的区域：

其中最重要，当然就是堆空间了，用户用于分配对象，是垃圾收集器管理的区域，由于垃圾回收期大都是基于分代收集理论设计的，堆的内部又被垃圾收集器分为新生代、老年代，新生代又被分为Eden、Survivor。

其次是方法区，里面存储的是Java类信息、常量、静态变量等信息，另外还包括运行时常量池，Java 8使用元空间来实现方法区。

### 一个类的加载过程是什么样的



### 一个对象创建的过程是什么样的



### JVM有哪些垃圾回收算法

首先是标记-清除算法，先标记出要回收的对象，再将这些对象回收掉，那么如果要回收的对象特别多，那么就要花费大量时间进行标记和删除，所以标记-清除算法多用于老年代，例如生产中最常见的垃圾收集器：CMS。

标记-清除算法的一个缺点是会产生大量的内存碎片，使得程序需要分配大对象的时候，可能就没有足够的空间了，不得不触发GC。

其次是标记-复制算法，将区域划分成两个区域，当一个区域的内存用完了的时候，会将该区域存活的对象复制到另一个区域，大部分新生代垃圾收集器都采用的该算法，例如Serial、ParNew，由于新生代绝大部分对象都熬不过第一轮回收，所以两个区域没必要1:1，HotSpot虚拟机默认的Eden和Survivor大小是8:1。

还有就是标记-整理算法，即标记过后，将存活的对象都移动到内存的一端，由于移动的成本要高于清除，所以这这种算法的缺点就是STW的时间会相对于标记清除算法更长，但是不存在内存碎片问题，可以通过指针碰撞来分配内存，效率更高，二者平衡下来，标记-整理算法的整体吞吐量更高，所以关注吞吐量的Parallel Scavenge收集器使用的是该算法，作用于新生代，也是Java8的默认垃圾收集器。

### 经典垃圾收集器有哪些

Serial，最早的垃圾收集器，新生代采用复制算法，老年代采用标记-整理算法，在回收时采用单线程进行回收，并且会造成STW。优点是额外内存消耗最小，适合小内存的客户端应用。

CMS，目标是尽可能低的延迟，作用于老年代收集器，采用的是标记-清除算法，它的回收分为四个过程：初始标记、并发标记、重新标记、并发清除，其中初始标记就是GC Roots能直接关联的对象，需要STW，但是速度很快，并发标记用时较长但是并不停顿用户线程，重新标记是修正并发标记期间程序运行导致的标记变动，也需要STW，最终并发清除，由于不需要移动对象，所以也可以和用户线程一起进行，整个过程延迟比较低，适合对延迟有要求的服务端。与CMS对应新生代收集器是ParNew，是Serial收集器的并发版本。

CMS的缺点是产生大量内存碎片，在Full GC时，整理内存碎片，停顿时间较长。

Parallel Scavenge是Java8默认的收集器，目标是达到一个可以控制的吞吐量，是一款新生代收集器，基于标记-复制算法，提供了参数可以控制系统停顿时间和吞吐量，系统是通过调整动态新生代和老年代的大小比例实现的，新生代小了，自然停顿时间就短了。与Parallel Scavenge对应的老年代收集器是Parallel Old收集器，支持并发收集，基于标记-整理算法。

### G1垃圾收集器的原理是什么



### G1垃圾收集器有什么优势

### 你们现在生产用的是什么垃圾收集器，出于什么考虑

### 说下JVM线上调优的经历

### 线上发生了OOM怎么处理

### 怎么排查内存泄漏



