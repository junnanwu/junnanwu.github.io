# 前端实战

## 路由

通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。

## JS

**逻辑运算符**

`||`

```javascript
var c = a() || b()
```

如果a()为true，直接短路，则表达式返回a()的值，**b()不执行**，如果a()为false，则执行b()并返回b()的值

`&&`

```javascript
var c = a() && b()
```

如果a()执行后为true，则执行b()并返回b()的值，如果a()执行后返回false，直接断路，则整个表达式返回a()的值，b()不执行

注意：

- 在js逻辑运算符中，**0,null,false,undefined,NaN**都会被判为false，其他为true

- &&优先级高于||

  ```javascript
  //结果为4
  alert(0&&3||1&&4)
  ```

**模版字符串**

```javascript
`${变量}`
```

ES6引入的模版字符串，用来解决字符串拼接问题

```javascript
var a = 1; console.log('一共有'+a+'个鸡蛋！')
//那么现在你只要
console.log(`一共有${a}个鸡蛋！`)
```

**拓展运算符**

`...`

它将一个数组转为用逗号分隔的参数序列

```javascript
var numbers = [4, 38];
add(...numbers) // 42
```

- 可用于合并数组

  ```javascript
  var arr1 = ['a', 'b'];
  var arr2 = ['c'];
  var arr3 = ['d', 'e'];
  // ES5 的合并数组
  arr1.concat(arr2, arr3);
  // [ 'a', 'b', 'c', 'd', 'e' ]
  // ES6 的合并数组
  [...arr1, ...arr2, ...arr3]
  // [ 'a', 'b', 'c', 'd', 'e' ]
  ```

- 还可以用于将字符串转换成数组

  ```javascript
  [...'hello']
  // [ "h", "e", "l", "l", "o" ]
  ```

### 计时器

setTimeout是指在指定时间后执行一次

setInterval以指定时间为周期循环执行

`setInterval()`的返回值是一个ID数字，可以奖这个ID传给`clearInterval()`以取消执行



#### setTimeout是同步的还是异步的？

```jsx
console.log('111');
setTimeout(()=>{
    console.log('222')
},1000);
console.log('333');
setTimeout(()=>{
    console.log('444')
},0);
console.log('555');
```

执行的结果为：

111 -> 333 -> 555 -> 444 -> 222

我们把需要执行的代码看成一个个任务，把任务分成两种，同步任务(sknchronous)，异步任务(asynchronous)。

 下面是它们的运行机制：

1. 所有同步任务都在主线程上，形成一个执行栈
2. 主线程之外还有一个“任务队列”，只要异步任务有了运行结果 ，就在任务队列中放一个事件
3. 当执行栈中所有的任务执行完了，就去看看任务队列中有没有需要执行的事件 ，如果有的话，就结束它们的等待，进入执行栈 ，开始执行。

所以上述代码的执行顺序为：

- 111进栈，执行完出栈
- 222进任务队列
- 333进栈，执行完出栈
- 444进任务队列
- 555进栈，执行完出栈
- 栈中执行完，开始任务队列，222执行，1秒后打印，444执行，立即打印

setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。
**需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。**

综上所属，setTimeout是单线程，类似异步，但不是异步 。

https://www.jianshu.com/p/4c377e876dac

### Array对象

#### some()

```javascript
let result = this._tableDataClone.some((item) => {
    return item.analysisFlag == 1
})
```

```javascript
array.some(function(currentValue,index,arr),thisValue)
```

`some()`用于检测数组中的元素是否满足指定条件（函数提供）;
`some()`方法会依次执行数组中的每一个元素：

- 如果有一个元素满足条件，则表达式返回true，剩余的元素不会再执行检测。
- 如果没有满足条件的元素，则返回false。

类似的方法还有every方法，他们的区别是：

只要数组中有一个元素满足条件，some() 就返回 true；只有当数组中的所有元素都满足条件时，every() 才返回 true。

#### splice()

```javascript
arrayObject.splice(index,howmany,item1,.....,itemX)
```

- index 规定添加，删除项目的位置
- howmany 必须，要删除的项目数量
- item1...X 可选，向数组中添加的新项目
- 返回值Array 包含被删除项目的新数组，如果有的话

实例：

- ```javascript
  arr.splice(2,0,"William")
  ```

  向数组中下标为2的位置添加一个“William”

- ```javascript
  arr.splice(2,1,"William")
  ```

  删除数组中下标为2的元素，并添加一个新元素来代替他

- ```javascript
  arr.splice(0, arr.length);
  ```

  清空数组

#### findIndex()

findIndex() 方法返回传入一个测试条件（函数）符合条件的数组**第一个**元素位置。

```javascript
var ages = [3, 10, 18, 20];
 
function checkAdult(age) {
    return age >= 18;
}
 
function myFunction() {
  	//结果为2
    alert(ages.findIndex(checkAdult));
}
```

## TS

### 变量

`!`的用法

在赋值的内容的后面使用，使null和undefined类型可以赋值给其他类型并通过编译

```typescript
// 由于x是可选的，因此parma.x的类型为number | undefined，无法传递给number类型的y，因此需要用x!
interface IDemo {
    x?: number
}

let y:number

const demo = (parma: IDemo) => {
    y = parma.x!
    return y
}
```

`?`的用法

- 表示可选参数
- 当使用A对象属性A.B时，如果无法确定A是否为空，则需要用A?.B，表示当A有值的时候才去访问B属性，没有值的时候就不去访问，如果不使用?则会报错

```typescript
// 由于函数参数可选，因此parma无法确定是否拥有，所以无法正常使用parma.x，使用parma?.x向编译器假设此时parma不为空且为IDemo类型，同时parma?.x无法保证非空，因此使用parma?.x!来保证了整体通过编译
interface IDemo {
    x: number
}

let y:number

const demo = (parma?: IDemo) => {
    y = parma?.x!
    console.log(parma?.x)   // 只是单纯调用属性时就无需!    
    return y
}
// 如果使用y = parma!.x!是会报错的，因为当parma为空时，是不拥有x属性的，会报找不到x的错误
```

但是?用法只能读操作而不能写操作，对一个可能为空的属性赋值是不会被编译通过的，此时还需用用到类型断言

```tsx
interface IDemo {
    x: number
}

// 编译报错，不能赋值给可选属性
const demo = (parma?: IDemo) => {
    parma?.x = 1    
}
    
// 使用类型断言  
const demo = (parma?: IDemo) => {
    let _parma = parma as IDemo
    _parma.x = 1
}
```

数组类型

有两种方式可以定义数组

- 

  ```ts
  let list: number[] = [1, 2, 3];
  ```

- 

  ```ts
  let list: Array<number> = [1, 2, 3];
  ```

### 接口

初始函数：

```ts
function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}
```

用接口描述：必须包含一个`label`属性且类型为`string`

```ts
interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}
```

`LabelledValue`接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 `label`属性且类型为`string`的对象。

接口的属性里面不全是必需的，可以在可选属性名字定义的后面加一个`?`

- 可选属性的好处之一是可以对可能存在的属性进行预定义
- 好处之二是可以捕获引用了不存在的属性时的错误。

```ts
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
}
```

#### 类型断言

AS

### 类

```ts
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
```

TypeScript里，成员都默认为 `public`

### 函数

```js
// Named function
function add(x, y) {
    return x + y;
}

// Anonymous function
let myAdd = function(x, y) { return x + y; };
```

TS改写

```ts
function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x + y; };
```

定义函数的时候也可以使用`?`实现可选参数

```ts
function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + " " + lastName;
    else
        return firstName;
}

let result1 = buildName("Bob");  // works correctly now
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");  // ah, just right
```

可选参数必须跟在必须参数后面。

#### 默认值

在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是`undefined`时。 它们叫做有默认初始化值的参数。

```ts
function buildName(firstName: string, lastName = "Smith") {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // works correctly now, returns "Bob Smith"
let result2 = buildName("Bob", undefined);       // still works, also returns "Bob Smith"
```

### 模块

模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用`export`形式之一导出它们。

相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 `import`形式之一。

#### 导出声明

任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加`export`关键字来导出。

#### 导入声明

导入一个模块中的某个导出内容

```ts
import { ZipCodeValidator } from "./ZipCodeValidator";
let myValidator = new ZipCodeValidator();
```

可以对导入内容重命名

```ts
import { ZipCodeValidator as ZCV } from "./ZipCodeValidator";
let myValidator = new ZCV();
```

将整个模块导入到一个变量，并通过它来访问模块的导出部分

```ts
import * as validator from "./ZipCodeValidator";
let myValidator = new validator.ZipCodeValidator();
```

#### 默认导出

每个模块都可以有一个`default`导出。 默认导出使用 `default`关键字标记；并且一个模块只能够有一个`default`导出。 需要使用一种特殊的导入形式来导入 `default`导出。

类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。

##### 类

ZipCodeValidator.ts

```ts
export default class ZipCodeValidator {
    static numberRegexp = /^[0-9]+$/;
    isAcceptable(s: string) {
        return s.length === 5 && ZipCodeValidator.numberRegexp.test(s);
    }
}
```

Test.ts

```ts
import validator from "./ZipCodeValidator";

let myValidator = new validator();
```

##### 函数

StaticZipCodeValidator.ts

```ts
const numberRegexp = /^[0-9]+$/;

export default function (s: string) {
    return s.length === 5 && numberRegexp.test(s);
}
```

Test.ts

```ts
import validate from "./StaticZipCodeValidator";

let strings = ["Hello", "98052", "101"];

// Use function validate
strings.forEach(s => {
  console.log(`"${s}" ${validate(s) ? " matches" : " does not match"}`);
});
```

##### 值

`default`导出也可以是一个值

OneTwoThree.ts

```ts
export default "123";
```

Log.ts

```ts
import num from "./OneTwoThree";

console.log(num); // "123"
```



### 命名空间

随着更多的



## VUE框架

VUE的生命周期

![Vue 实例生命周期](%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98_assets/lifecycle.png)

用document在created函数中就获取不到元素

但是在mounted函数中可以获取到元素













- main.ts是入口文件

- 引入 vue 和 component 的方式变了（记下就行了，不用去管为什么）

  ```javascript
  import { Component, Vue } from "vue-property-decorator";
  ```

- 不用写 data 了

- method 直接写就好了，不用写 methods 了

简单实例：

html

```html
<div id="app">
    <!-- 1.渲染数据 -->
    {{msg}}
    <div>
    <!-- 2.添加事件监听 -->
    <button @click="fn">点我</button>
    </div>
</div>
```

ts

```ts
@Component({
  // 3.props写这里
  // 这个组件接受一个props,叫做name
  props: {
    name: String
  }
  
})
 
export default class App extends Vue {
  //1.这里声明 data
  msg = 123;
 
  //2.这里声明method
  fn() {
    alert("fn");
  }
}
```

@Component的作用：
首先，Component 是一个函数。

作用：把 @Component 里对象的属性，添加到下面的类里面。其实对象里的属性，就是下面类的一些属性。

区别：export 里包裹的属性，是组件特有的属性。而 @Component 里的属性，key是固定的，只有那么几项。（简而言之，就是@Component 里的key，是所有组件共有的 key，下面的 key 是某些组件特有的 key）

总结：上面，共有，下面，特有。通过 @Component 就可以把它们分隔开来。
好处：共有属性不会写错

引入Echarts报错：

**TypeScript通过在报错一行上方使用 // @ts-ignore来忽略错误**

