# CAS

synchronized和ReentrantLock都属于互斥同步，都通过线程阻塞和唤醒来实现，因此也被称为阻塞同步，阻塞同步属于悲观策略，其总认为只要不加锁，就肯定出问题，所以无论共享的数据真的会出现竞争，它都会进行加锁。

随着硬件指令集的发展（需要将冲突检测操作原子化），我们已经有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了。

如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步。

在Java中的展示就是CAS操作。

CAS指令需要有三个操作数，分别是：

- 内存位置（在Java中可以简单地理解为变量的内存地址，用V 表示）
- 旧的预期值（用A表示）
- 准备设置的新值（用B表示）

CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。

## ABA问题

如果一个变量V初次读取的时候是A 值，并且在准备赋值的时候检查到它仍然为A值，那就能说明它的值没有被其他线程改变过了吗？这是不能的，因为如果在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的**ABA问题**。

`J.U.C`包为了解决这个问题，提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类处于相当鸡肋的位置，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更为高效。