# 线程池

### 线程池架构

- Executor接口

  ```java
  void execute(Runnable command);
  ```

- ExecutorService接口

  - 线程池关闭

    ```java
    // 关闭线程池，该方法执行后，拒绝接受新任务，但之前提交的任务继续执行
    void shutdown();
    
    // 立即关闭线程池，该方法执行后，停止所有正在执行及正在等待的任务，并返回等待执行的任务列表
    List<Runnable> shutdownNow();
    
    // 判断线程池是否为shutdown状态
    boolean isShutdown();
    
    // 判断线程池是否为terminated状态
    boolean isTerminated();
    
    // 在shutdown请求后，阻塞等待所有任务执行完毕
    boolean awaitTermination(long timeout, TimeUnit unit)
            throws InterruptedException;
    ```

  - 异步任务提交

    ```java
    // 提交可执行的任务，并返回Future
    // 任务执行完毕后，Future#get()方法返回任务执行的结果
    <T> Future<T> submit(Callable<T> task);
    
    // 提交可执行的任务，并返回Future
    // 任务执行完毕后，Future#get()方法返回任务执行的结果给result
    <T> Future<T> submit(Runnable task, T result);
    
    // 提交可执行的任务，并返回Future
    // 任务执行完毕后，Future#get()方法返回null
    Future<?> submit(Runnable task);
    ```

- ScheduledExecutorService

  ```java
  // 在给定延时后，创建并执行一个Runnable任务
  // 任务执行完毕后，ScheduledFuture#get()方法会返回null
  public ScheduledFuture<?> schedule(Runnable command,
                                         long delay, TimeUnit unit);
  // 在给定延时后，创建并执行一个Callable任务
  // 任务执行完毕后，ScheduledFuture#get()方法会返回任务执行结果                                
  public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                                             long delay, TimeUnit unit);
  
  // 在给定延时后，周期性创建并执行Runnable任务
  public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                    long initialDelay,
                                                    long period,
                                                    TimeUnit unit);
  
  // 在给定延时后，周期性创建并执行Runnable任务(上次任务结束时间和当前任务开始时间间隔相同)
  public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
                                                       long initialDelay,
                                                       long delay,
                                                       TimeUnit unit);
  ```

- ThreadPoolExecutor

  ```java
  public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler) {
      if (corePoolSize < 0 ||
          maximumPoolSize <= 0 ||
          maximumPoolSize < corePoolSize ||
          keepAliveTime < 0)
          throw new IllegalArgumentException();
      if (workQueue == null || threadFactory == null || handler == null)
          throw new NullPointerException();
      this.corePoolSize = corePoolSize;
      this.maximumPoolSize = maximumPoolSize;
      this.workQueue = workQueue;
      this.keepAliveTime = unit.toNanos(keepAliveTime);
      this.threadFactory = threadFactory;
      this.handler = handler;
  }
  ```

### ThreadPoolExecutor

参数解释：

- corePoolSize

  核心线程数：也没有用的时候，也不会被回收

- maximumPoolSize

  最大线程数

- keepAliveTime

  线程池中最大线程数的存活时间大小

- unit

- workQueue

  - ArrayBlockingQueue

    有届队列，是一个用数组实现的有届阻塞队列，按FIFO排序

  - LinkedBlockingQueue

    基于链表结构的阻塞队列 ，按FIFO排序任务，容量可以选择设置，不设置的话，将是一个无界阻塞队列，最大长度为`Integer.MAX_VALUE`，吞吐量通常要高于ArrayBlockingQuene

    newFixedThreadPool线程池使用了这个队列

  - DelayQueue

    延迟队列，是一个任务定时周期的延迟执行的队列，根据指定的执行时间从小到大排序，否则就根据插入到队列的先后排序

    newScheduledThreadPool线程池使用了这个队列

  - PriorityBlockingQueue

    优先级队列，是具有优先级的无界阻塞队列

  - SynchronousQueue

    同步队列，一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作就一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue

    newCachedThreadPool线程池使用了这个队列

- threadFactory

- handler

  线程池的饱和策略

  - AbortPolicy(抛出一个异常，默认的)
  - DiscardPolicy(直接丢弃任务)
  - DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）
  - CallerRunsPolicy（交给线程池调用所在的线程进行处理)

![13029560-24ee67baf698f36c](%E7%BA%BF%E7%A8%8B%E6%B1%A0_assets/13029560-24ee67baf698f36c.png)

### 给定的几种线程池

Executors工具类，提供了常用的几种线程池

- FixedThreadPool

  ```java
  public static ExecutorService newFixedThreadPool(int nThreads) {
      return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>());
  }
  ```

  该线程池中有固定数目的工作线程，可以同时运行N个任务，当提交的任务数大于N的时候，后提交的任务将添加到阻塞队列，等待线程池汇总出现空闲的线程。

- SingleThreadExecutor

  ```java
  public static ExecutorService newSingleThreadExecutor() {
      return new FinalizableDelegatedExecutorService
          (new ThreadPoolExecutor(1, 1,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>()));
  }
  ```

  该线程池只能同时运行一个任务，其他任务只能在阻塞队列中等待

- CachedThreadPool

  ```java
  public static ExecutorService newCachedThreadPool() {
      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
  }
  ```

  如果线程池中无可用线程，则会新建一个线程添加到线程池中，当线程池超过60秒未使用，就自动从线程池中移除

- ScheduledExecutorService

  ```java
  public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
      return new ScheduledThreadPoolExecutor(corePoolSize);
  }
  ```

  

### 线程池的状态

![13029560-36fa7790d40596d0](%E7%BA%BF%E7%A8%8B%E6%B1%A0_assets/13029560-36fa7790d40596d0.png)

- RUNNING

  该状态的线程池会接受新的任务，并处理阻塞队列中的任务

  调用线程池的`shutdown()`方法，可以切换到SHUTDOWN状态

  调用线程池的`shutdownNow()`方法，可以切换到STOP状态

- SHUTDOWN

  该状态的线程池不会接受新的任务，但是会处理阻塞队列中的任务

  队列为空，并且线程池总执行的任务也空，进入TIDYING状态

- STOP

  该状态的线程不会接受新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务

  线程池汇中执行的任务为空，进入TIDTING状态

- TIDYING

  该状态表明所有的任务已经运行终止，记录的任务数量为0

  `terminated()`执行完毕，进入TERMINATED状态

- TERMINATED

  该状态表示线程池彻底终止

### 线程池的异常处理

### 线程池的参数如何配置

### 如何中止线程池

`shutdown()`

### ThreadPoolTaskExecutor

```java
@Configuration
@EnableAsync
public class SpringThreadPoolExecutorConfig {

    @Bean(name = "threadPoolTaskExecutor")
    public ThreadPoolTaskExecutor threadPoolTaskExecutor() {
        ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
        //线程最大空闲时间
        //除了核心线程 其他线程当超过等待时间keepAliveTime 就会进行线程移除
        pool.setKeepAliveSeconds(300);
        //核心线程池数
        pool.setCorePoolSize(2);
        //最大线程
        pool.setMaxPoolSize(5);
        //队列容量
        pool.setQueueCapacity(1000);
        //队列满，线程被拒绝执行策略
        pool.setRejectedExecutionHandler(new java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy());
        pool.setThreadNamePrefix("aaaa-common-support-service--");
        return pool;
    }
}
```

```java
@Slf4j
@Service("AAAAAService")
public class AAAAAServiceImpl implements AAAAAService {
 
 
	@Autowired
	private ThreadPoolTaskExecutor threadPoolTaskExecutor;
 
 
	@Override
	public List<String> queryUserByGivenname(String txNo, String givenname)
			throws ParamInvalidException {	
	
			threadPoolTaskExecutor.execute(()->{
 
				log.info("-------txNO[{}],givename[{}]", txNo,givenname);
			
			});
		
		return null;
	}
}
```

### 线程工厂

`ThreadFactory`是一个线程工厂，用来在创建线程的时候，设置一些线程名字，优先级等参数。

```java
public interface ThreadFactory {
    Thread newThread(Runnable r);
}
```

最简单的实现如下：

```java
class SimpleThreadFactory implements ThreadFactory {
    public Thread newThread(Runnable r) {
        return new Thread(r);
    }
}
```

当我们不指定的时候，使用的是默认的实现：

```java
static class DefaultThreadFactory implements ThreadFactory {
    private static final AtomicInteger poolNumber = new AtomicInteger(1);
    private final ThreadGroup group;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null) ? s.getThreadGroup() :
        Thread.currentThread().getThreadGroup();
        namePrefix = "pool-" +
            poolNumber.getAndIncrement() +
            "-thread-";
    }

    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r,
                              namePrefix + threadNumber.getAndIncrement(),
                              0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}
```



## 问题

- 在单元测试中出现`java.lang.InterruptedException: sleep interrupted`异常

  ```java
  @Test
  public void test01() throws InterruptedException {
    threadPoolTaskExecutor.execute(() -> {
      try {
        Thread.sleep(2000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    });
  }
  ```

  会跑出中断异常，是因为单元测试的主线程提前结束，主线程强制打断子线程的sleep，因此抛出异常。由 Thread 提供并受 Thread.sleep() 和 Object.wait() 支持的中断机制就是一种取消机制；它允许一个线程请求另一个线程停止它正在做的事情。当一个方法抛出 InterruptedException 时，它是在告诉您，如果执行该方法的线程被中断，它将尝试停止它正在做的事情而提前返回，并通过抛出 InterruptedException 表明它提前返回。 行为良好的阻塞库方法应该能对中断作出响应并抛出 InterruptedException，以便能够用于可取消活动中，而不至于影响响应。

https://www.jianshu.com/p/ff79dc168e1a

