# 垃圾回收机制

## 哪些内存需要回收

Java堆和方法区，只有处于运行期间我们才知道程序会创建哪些对象，创建多少个对象。

## 什么时候回收

### 引数计数算法

在对象中添加一个引用计数器，每当有一个地方引用它的时候，计数器加一，当引用失效的时候，计数器就减一。

引数计数法在很多应用都有应用，但是在Java中，主流的Java虚拟机都没有选用引用计数法来管理内存，因为这个算法有很多例外需要考虑，例如对象之间的循环引用问题。

#### 引用类型

在Java2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用和虚引用，这四种引用的强度，依次减弱。

- 强引用

  指的是程序代码之间普遍存在的引用赋值，类似`Object obj = new Object()`这种引用关系，只要强引用关系还在，垃圾收集器就永远不会回收被引用的对象。

- 软引用 

  描述一些还有用的，但非必需的对象，只被软引用关联的对象，在系统要发生内存溢出之前，会进行二次回收，Java2之后提供了SoftReference类来实现软引用。

- 弱引用

  描述非必需的引用，被弱引用关联的对象只能生存到下一次垃圾收集器发生为止，当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java2之后提供了WeakReference类来实现弱引用。

- 虚引用

  略。

### 可达性分析算法

当前主流的语言内存管理都是通过可达性分析算法来判定对象是否存活的，这个算法的思路就是通过一系列GC Roots的根对象作为起始节点集，分局引用关系向下搜索，如果某个对象到GC Roots之间没有任何引用链相连，则证明此对象是不可能再被引用的。

在Java中，固定可以作为GC Roots的对象包括以下几种：

- 在虚拟机栈中引用的对象，例如各个线程方法堆栈中使用到的参数、局部变量、临时变量等
- 在方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 被同步锁持有的对象

## 如何回收

### 回收方法区

方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。

假如一个字符串`java`曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是`java`，换句话说，已经没有任何字符串对象引用常量池中的`java`常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个`java`常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似。

### 垃圾回收算法 

#### 分代收集理论

分代收集理论建立在两个分代假说之上：

- 弱分代假说

  绝大多数对象都是朝生夕灭的。

- 强分代假说

  熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

设计者一般会把Java堆内存分为两个区域：

- 新生代

  每次垃圾收集时都有大批的对象死去，而每次回收之后存活的少量对象，将会逐步晋升到老年代中存放。

- 老年代

## References

1. 《深入理解Java虚拟机》——周志明 