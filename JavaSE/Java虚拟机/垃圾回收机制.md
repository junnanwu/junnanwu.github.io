# 垃圾回收机制

## 哪些内存需要回收

Java堆和方法区，只有处于运行期间我们才知道程序会创建哪些对象，创建多少个对象。

## 什么时候回收

### 引数计数算法

在对象中添加一个引用计数器，每当有一个地方引用它的时候，计数器加一，当引用失效的时候，计数器就减一。

引数计数法在很多应用都有应用，但是在Java中，主流的Java虚拟机都没有选用引用计数法来管理内存，因为这个算法有很多例外需要考虑，例如对象之间的循环引用问题。

#### 引用类型

在Java2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用和虚引用，这四种引用的强度，依次减弱。

- 强引用

  指的是程序代码之间普遍存在的引用赋值，类似`Object obj = new Object()`这种引用关系，只要强引用关系还在，垃圾收集器就永远不会回收被引用的对象。

- 软引用 

  描述一些还有用的，但非必需的对象，只被软引用关联的对象，在系统要发生内存溢出之前，会进行二次回收，Java2之后提供了SoftReference类来实现软引用。

- 弱引用

  描述非必需的引用，被弱引用关联的对象只能生存到下一次垃圾收集器发生为止，当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java2之后提供了WeakReference类来实现弱引用。

- 虚引用

  略。

### 可达性分析算法

当前主流的语言内存管理都是通过可达性分析算法来判定对象是否存活的，这个算法的思路就是通过一系列GC Roots的根对象作为起始节点集，分局引用关系向下搜索，如果某个对象到GC Roots之间没有任何引用链相连，则证明此对象是不可能再被引用的。

在Java中，固定可以作为GC Roots的对象包括以下几种：

- 在虚拟机栈中引用的对象，例如各个线程方法堆栈中使用到的参数、局部变量、临时变量等
- 在方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 被同步锁持有的对象

## 如何回收

### 回收方法区

方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。

假如一个字符串`java`曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是`java`，换句话说，已经没有任何字符串对象引用常量池中的`java`常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个`java`常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似。

### 垃圾回收算法 

#### 分代收集理论

分代收集理论建立在两个分代假说之上：

- 弱分代假说

  绝大多数对象都是朝生夕灭的。

- 强分代假说

  熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

设计者一般会把Java堆内存分为两个区域：

- 新生代
- 老年代

每次垃圾收集时都有大批的对象死去，而每次回收之后存活的少量对象，将会逐步晋升到老年代中存放。

#### 标记-清除算法

标记清除算法（Mark-Sweep）分为标记和清除两个阶段，首先标记出所有需要回收的对象，然后统一回收掉所有被标记的对象。

缺点：

- 执行效率不稳定，如果Java堆中包含大量对象，而且大部分都是需要被回收的，这时必须进行大量标记和清除操作，导致执行效率随着对象数量的增多而降低。
- 内存空间的碎片化问题

![mark_sweep](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6_assets/mark_sweep.png '标记清除算法示意图')

#### 标记-复制算法

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，出现了"半区复制"的垃圾回收算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块用完了，就将还存活着的对象复制到另外一块上面去，然后再将已使用过的内存空间一次性清除掉。

如果内存中多数对象都是可回收的，那么需要复制的就是少数存活的对象，而且一次针对半区进行回收，不会产生空间碎片的情况。

缺点就是，将可用内存缩小为了原来的一半。

![mark_copy](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6_assets/mark_copy.png '标记复制算法示意图')

现在商用Java虚拟机大多采用这种收集算法。

> IBM公司曾有一项专门研究对新生代"朝生夕灭"的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集。

因此并不需要1:1的比例来划分新生代的内存空间。

Andrew Appel针对具备"朝生夕灭"特点的对象，提出了更优化的半区复制分代策略，现在称为"Appel式回收"：

将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次内存分配，只使用Eden和其中一块Survivor，发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。

HotSpot虚拟机默认的Eden和Survivor大小比例是8:1，即每次新生代中可用内存空间为整个新生代容量的90%，只有10%的新生代是浪费的。

Appel式回收还有一个充当罕见情况的"逃生门"的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保(Handle Promotion)。

#### 标记-整理算法

标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

针对老年代对象的存亡特征，出现了一种针对性的标记-整理算法（Mark-Compact），将所有存活的对象进行标记，然后向内存的一边进行移动。

![mark-compact](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6_assets/mark-compact.png '标记整理算法示意图')

## References

1. 《深入理解Java虚拟机》——周志明 