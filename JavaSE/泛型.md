# 泛型

## 为什么会有泛型

用ArrayList举例子，要想实现ArrayList里面装任何类型，可以使用Object，实际上，在泛型出现之前，ArrayList也确实是这样设计的。

```java
public class ArrayList{
    private Object[] elementData;
    ...
    public Object get(int i){...}
    public void add(Object o)
}
```

这种方式存在两个问题：

- 当取一个值时必须进行强制转换

- 没有错误检查，可以向数组中添加任何类的值

  这样就会造成编译和运行的时候都没有错误，但是在某个地方get后进行强制转换的时候产生错误

基于这种情况，为了在编辑阶段就能解决这些问题，Java5中引入了泛型。

泛型提供了泛型参数（type parameter）

```java
ArrayList<String> names = new ArrayList<>();
```

带来的好处：

- 编译器就会充分利用这个信息，调用get的时候，不需要进行强制类型转换，编译器知道返回类型是String而不是Object

  ```java
  String name = names.get(0);
  ```

- 另一方面，编译器还知道add方法里面有一个类型为String的参数，它会进行检查，防止你插入错误类型的对象，让你的程序更易读，也更安全

## 什么时候使用泛型

如果代码中原本要使用大量的通用类型（Object或Comparable）的强制类型转换，这些代码适合使用泛型。

## 泛型应用

泛型主要分为两种

- 泛型类/泛型接口

  实例化的时候指明泛型的具体类型

- 泛型方法

  在调用方法的时候指定泛型的指定类型

### 泛型类

类型变量放在类名的后面

```java
public class Generic<T>{ 
    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}
```

典型的就是各种容器类

### 泛型接口

泛型接口与泛型类基本相同，通常被用到各种类的生产器中

```java
public interface Generator<T> {
    public T next();
}
```

当实现泛型的类，未传入泛型参数的时候，该类也需要生命该泛型参数

```java
class FruitGenerator<T> implements Generator<T>{
    @Override
    public T next() {
        return null;
    }
}
```

当实现接口，传入泛型实参时，该类不需要再指定泛型参数

```java
public class FruitGenerator implements Generator<String> {

    private String[] fruits = new String[]{"Apple", "Banana", "Pear"};

    @Override
    public String next() {
        Random rand = new Random();
        return fruits[rand.nextInt(3)];
    }
}
```

### 泛型方法

**泛型变量放在修饰符的后面，返回类型的前面**，泛型方法可以定义在普通类中，也可以定义在泛型类中定义

当调用一个泛型方法对的时候，可以把具体类型包围在尖括号中，放在方法名前面

### 泛型变量限定

假设我们想让我们使用的泛型都拥有一个compareTo()方法，那ß么我们可以使用extends关键字来限定T

```java
pulic static <T extends Comparable> T min(T[] a) ...
```

一个类型变量可以有多个限定，如果有一个类限定，那么类限定必须放在接口限定前面，例如:

```java
T extends Comparable & Serializable
```

## 泛型与虚拟机

虚拟机在编译过程中，正确正确检查类型结果后，会对泛型进行擦除，例如对于无限定泛型，就会被替换为Object，在存取的时候，也会加入强制类型转换。

```java
List<String> stringArrayList = new ArrayList<String>();
List<Integer> integerArrayList = new ArrayList<Integer>();

Class classStringArrayList = stringArrayList.getClass();
Class classIntegerArrayList = integerArrayList.getClass();

//上面两种类型是相同的
if(classStringArrayList.equals(classIntegerArrayList)){
    System.out.println("类型相同");
}
```

## 注意

- 不能用基本类型代替类型参数，原因就是当擦除泛型之后，泛型被替换为Object，而Object类型不能接收基本类型。
- 不能使用带有泛型变量的静态字段和方法

## 泛型生产应用

reference1：*《Java核心技术卷1》*

[reference2](https://blog.csdn.net/s10461/article/details/53941091)

