# MySQL InnoDB

InnoDB是一个将表中数据存储到磁盘的存储引擎。InnoDB处理数据是发生在内存中的，需要把磁盘中的数据加载到内存中，InnoDB以页作为磁盘和内存之间交互的基本单位，InnoDB中页的默认大小为16KB。

测试：

```
SHOW VARIABLES LIKE "innodb_page_size"
-- 结果为16KB
innodb_page_size: 16384
```

注意：此变量在mysql运行时不可更改

我们平时是以记录为单位向表中插入数据的，这些记录的格式被称为行格式，共有四种：

- Dynamic
- Compact
- Redundant
- Compressed

测试：

```
SHOW VARIABLES LIKE "innodb_default_row_format"
--
innodb_default_row_format: dynamic
```

## 变长字段长度列表

![20210603182014243](Mysql-InnoDB_assets/mysql_innoDB_store_type.png)

一些变长的数据类型，比如`VARCHAR(M)`、各种`TEXT`类型，各种`BLOB`类型，变长数据类型的字段中存储多少字节的数据是不固定的，在存储真实数据的时候需要把**这些数据占用的字节数也存起来**

innodb分配了两个字节去记录表示varchar的字节数，所以记录的范围就是2^16-1=65535

InnoDB中，最多能存储字节数 = 最多能存储字符数 * 该编码中最大的字节数

对于该编码中最大的字节数，例如：

- `utf8mb4`字符集是`4`
- `utf8`字符集是`3`
- `gbk`字符集是`2`
- `ascii`字符集是`1`

所以，当使用`utf8mb4`的时候，会提示`varchar`类型最大16383个，即65535/4=16383.75

但是，如上述，即使提示16383，行里很多东西，包括变长字段，NULL值列表，记录头信息等，所以即使提示16383也绝不可能存到16383。

经测试：

建一个有一列的表，字符集采用`utf8mb4`，类型`varchar(16383)`，然后后向这个字符中添加值，字符总极限为48545字节，超出即会报错。

结果是远不到65535字节，主要是因为溢出列的原因，数据分散在不同的行中，所以，很长的数据，建议往`text`类型考虑。

- `InnoDB`在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数(最大字符数*编码最大字节数)不大于255时，只用1个字节来表示真实数据占用的字节。
- 如果允许存储的最大字节数大于255，则分为两种情况（这里存疑）
  - 如果实际存储字节 <= 127，`varchar`占用的真实字节数仅分配1个字节就能表示
  - 如果实际存储字节 > 127，`varchar`占用的真实字节数需要分配2个字节才能表示
- 变长字段长度列表只会存储非null值的长度

## NULL值列表

如果表中的某些列可能存储`NULL`值，把这些`NULL`值都放到**记录的真实数据**中存储会很占地方，所以`dynamic`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中。

过程如下：

- 统计表中允许存储`NULL`的列有哪些
- 将每个允许存储`NULL`的列对应一个二进制位，二进制位按照列的顺序**逆序排列**
- `NULL`值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的**高位补0**

例如：

```
建一个a,b,c,d四列的表，其中，d不允许为NULL
那么，一条记录的NULL值列表格式为：0000 0cba

当存入1,null,null,1时
此记录的NULL值列表为：0000 0110
```

## 溢出列

对于占用存储空间非常多的列，在记录真实数据时，**该列只会用`20`字节空间**，而这`20`字节的空间不存储数据，因为数据都分散存储在其他几行中了。这`20`字节的空间存储的是分散行的地址和占用的字节数。分散行记录是单链表连接的结构。