# MySQL锁

## 表锁

### Server级别

LockTables语句手动锁定表（Server级别，即Mysql级别的锁）

- 读锁定

  ```SQL
  LOCK TABLES tableName READ;
  ```

  如果一个线程获得一个表上的read锁，那么所有线程只能进行读操作。

- 写锁定

  ```SQL
  LOCK TABLES tableName WRITE；
  ```

  如果一个线程在一个表上得到一个write锁，那么只有这个线程能从这个表中读和写表，其他线程阻塞。

### 意向锁

如果我们要想给一个表加read锁，就要遍历所有行，判断这个表中有没有行锁，非常麻烦，所以InnoDB采用意向锁的方式来优化这一过程，**要想获得细粒度的锁，必须获得粗粒度的意向锁**。

InnoDB提供了表级别的意向锁：

- 意向共享锁（IS Lock）

  事务在给数据行权限加行级共享锁之前，必须先取得该表的意向共享锁。

- 意向拍他锁（IX Lock）

  事务在给数据行权限加行级排他锁之前，必须先取得该表的意向拍他锁

## 行锁

InnoDB采用了两种不同的行锁：

- 共享锁（读锁、S Lock）读锁和读锁不互斥
- 排他锁（写锁、X Lock）**写锁和其他锁都互斥**

上锁方式：

即使是Select语句，InnoDB也支持加行级锁。

- 共享锁

  ```SQL
  SELECT ... LOCK IN SHARE MODE
  ```

- 拍他锁

  ```SQL
  SELECT ... FOR UPDATE
  ```

行锁有三种算法：

- 记录锁，单个行记录上的锁
- 间隙锁，锁定一个范围，但不包括记录本身
- Next-Key锁，即记录锁+间隙锁，为了解决幻读问题

例如一个索引有10，11，13，20这四个值，那么该索引就会被Next-Key锁分为区间：

- `(-∞,10]`
- `(10,11]`
- `(11,13]`
- `(13,+∞]`

当查询的索引含有唯一索引的时候，Next-Key锁会降级为Record Lock，即仅锁住索引本身，而不是范围。

间隙锁的作用就是阻止多个事务将记录插入到同一范围内，间隙锁只存在可重复读级别。

### 间隙锁解决幻读问题

幻读指的是，在同一事务下，连续执行两次同样的SQL语句导致第二次返回了之前不存在的行。

例如一个表由1、2、5这三个值构成，此时事务T1执行下面的SQL：

```SQL
SELECT * FROM table WHERE a > 2 FOR UPDATE;
```

此时T1并没有提交事务，上述结果会返回5，但是此时当事务T2插入了4这个值（假设此时没有间隙锁），那么T1再次执行同样的语句就会返回4和5，违反了事务的隔离性。

InnoDB采取Next-Key锁来解决幻读问题，对于上述语句，在`(2,+∞)`这个区间，加上了拍他行锁。因此这个范围内的其他数据都是无法插入的，就避免了幻读问题。

## MVCC

我们知道，行级写锁和行级读锁是互斥的，也就是说，当一行正在被修改的时候，其他事务是不能读取该行的，这就大大降低了并发能力。

InnoDB采取了多版本并发控制（MVCC），来提高并发能力，并保证不同事务之间的隔离性。

在读已提交和可重复读级别下，InooDB采取MVCC，但是两个级别对快照数据的定义不同。

- 读已提交级别

  总是读取被锁定行的最新一份的快照数据。

  所以该隔离级别下，A开启事务后，读到记录X，B事务修改X为X'，并提交事务，这个时候，A事务再次读取，发现读到的是最新的记录X'，造成了不可重复读，这已经违反了事务的隔离性。

- 重复读级别

  读取事务刚开始的行数据版本。

  这就避免了上述不可重复读问题。

MVCC下，读取行数据是不需要加锁的，已经加了拍他锁的行也是可以进行读取的。

## References

1. 《MySQL技术内幕 - INNODB存储引擎》——姜承尧



